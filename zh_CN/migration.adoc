= Activiti迁移手册：Activiti v5到Activiti v6 (Activiti Migration Guide : Activiti v5 to Activiti v6)
:doctype: book
:docinfo1: header
:icons: font
:numbered:
:source-highlighter: pygments
:pygments-css: class
:pygments-linenums-mode: table
:compat-mode:
:nofooter:

== 介绍 Introduction

本手册介绍了从Activiti v5.x迁移至Activiti v6时需要注意的事项。这是一个迁移手册的初步版本，并将在后续Activiti v6发布alpha/beta版本时更新，因为很多东西仍在修改之中。到时，本迁移手册将规范化，而用户手册也将更新，一反应Activiti v6中的所有特性与功能。

**当前的Activiti v6版本只用作测试目的！请不要在生产环境使用。**这个版本的主要目的是收集反馈，报告问题以及让用户可以在v6版本上测试他们的流程定义。当然，与之前一样，欢迎大家访问GitHub页面并做贡献。Activiti v6的代码目前处在link:$$https://github.com/Activiti/Activiti/tree/activiti6$$[__activiti6__分支]。

== 设计目标 Design goals

v6版本的设计目标是：

* 完全向上兼容v5版本：数据库层面、概念层面以及代码层面。
* 重写核心引擎：直接执行BPMN 2.0（不再转换为中间模型）。
* 更简洁干净的运行时执行数据结构，并加强对结构的预判性。
* 解耦持久层，以支持未来可能的不同实现。


== 数据库迁移 Database migration

从v5至v6不需要数据库迁移：v5与v6的数据库表结构已知。所有Activiti v5生成的数据都可以保留在数据库中。在v6引擎第一次运行时，会对表结构进行自动升级（同v5版本中一样）。除了一些小的数据库结构改动外，主要的改动是将作业表分拆为作业表、定时器作业表、暂停作业表与死信作业表。还未到期的定时器作业将移至新的定时器作业表；用尽重试次数的作业将移至死信作业表；已暂停流程实例的作业将移至暂停作业表。

== 概念变化 Conceptual changes

称为Activiti v6的主要原因是完全重写了核心引擎。核心引擎执行的方式已经完全改变，将直接执行BPMN（在v5中使用中间模型）。同时运行时执行的表现形式（__执行树__）也作了修改。总的来说，这些概念都大幅简化了，让执行更简单清晰，也让撰写的自定义行为更容易更易懂。

未来，我们将详细介绍引擎内部的工作。对v6版本的概要介绍可以查看link:$$http://www.jorambarrez.be/blog/2015/06/18/activiti-6-launch/$$[Activiti 6发布记录]。

== 破坏性改变 Breaking changes

下列改变是破坏性改变（也就是说很可能导致编译错误）……

=== PVM类 PVM classes

org.activiti.engine.impl.pvm包（及其子包）下的所有类都已移除。这是因为__PVM__ (流程虚拟机 Process Virtual Machine)模型已被移除，并被一个更简单更轻量的模型替代。

这意味着__ActivitiImpl__、__ProcessDefinitionImpl__、__ExecutionImpl__及__TransitionImpl__的使用都将失效。

总的来说，在v5中这些类大多用于获取流程定义中包含的信息。在v6中，所有流程定义的信息都可以通过__BpmnModel__获取。这是一个BPMN 2.0 XML流程定义的Java表现形式（对特定操作及搜索进行了增强）。

获取__BpmnModel__流程定义最快捷的方法是使用org.activiti.engine.impl.util.ProcessDefinitionUtil类：

----
// 整个模型 The whole model
ProcessDefinitionUtil.getBpmnModel(String processDefinitionId);

// 只有特定流程定义 Only the specific process definition
ProcessDefinitionUtil.getProcess(String processDefinitionId);
----

=== ActivityExecution被DelegateExecution代替 ActivityExecution is replaced by DelegateExecution

我们移除了ActivityExecution，并使用DelegateExecution类代替它。

所有ActivityExecution类中的方法都已复制到DelegateExecution类中。

=== 作业、定时器、暂停与死信作业 Job, timer, suspended and dead letter jobs

Activiti 5中只有一个作业表，导致查询需要执行的作业时，查询条件异常复杂。

在Activiti 6中，作业被分拆成了作业表(ACT_RU_JOB)、定时器表(ACT_RU_TIMER_JOB)、暂停表(ACT_RU_SUSPENDED_JOB)与死信表(ACT_RU_DEADLETTER_JOB)。

* 作业表中的作业将可以直接执行（类似异步作业与到期定时器作业）。因此就不需要使用复杂的查询，唯一的where条件是lock time(锁定时间)不能为NULL。
* 定时器作业现在持久化在专门的定时器作业表中，并由一个线程检查到期需要执行的定时器作业。当定时器作业到期需要执行时，改作业会被移至作业表。
* 当流程定义或流程实例暂停时，其关联的作业将被移至单独的暂停作业表。这简化了作业执行器的查询，并清楚显示了暂停中的作业。
* 如果一个作业执行失败，它将被放入定时器作业表，并用 当前时间+引擎配置的作业失败等待时间 作为到期日期。在该作业到期将被执行时，会重新移至作业表，并被执行。如果重试次数减至0，则该作业将被移至死信表，不再自动执行。这也简化了默认的作业执行器查询，也清楚显示了卡住需要人工干预的作业。

Activiti 6中嵌入的Activiti 5引擎也能够使用这4个作业表。但是只会有一个线程池从数据库中获取作业。当获取到一个作业后，会基于流程定义id检查引擎的版本，以判断作业由Activiti 6还是嵌入的Activiti 5引擎执行。

=== Signaling an execution

In version 5, there always was confusion about _signaling an execution_, when using for example _runtimeService.signal(executionI);_. As a _signal_ is a valid BPMN 2.0 concept and feature, it conflicts conceptually.

In version 6, the _signal()_ methods have been renamed to _trigger()_..

This also means that _SignalableActivityBehavior_, the interface to be implemented for behaviors that can be _triggered_ from external sources, is now called _TriggerableActivityBehavior_.

=== Checked Exceptions

In version 5, the delegate classes like _JavaDelegate_ and _ActivityBevior_ had _throws Exception_ in their signature. As with any modern framework, the use of checked Exceptions has been removed in version 6.

=== Delegate classes

_org.activiti.engine.impl.pvm.delegate.ActivityBehavior_ has changed package and lives now in _org.activiti.engine.impl.delegate_.

The following methods have been removed from _DelegateExecution_:

* end()
* createdExecution()

They have been replaced by calls to the ExecutionEntityManager, which can be fetched through Context.getCommandContext.getExecutionEntityManager().

=== EntityManagers

In Activiti version 5, all EntityManager (responsible for persistence but also certain logic) classes did not have an interface. In version 6, all EntityManager classes have been renamed to have _Impl_ as suffix and an interface without the suffix. This effectively means that the version 5 EntityManager class name is now the name of the corresponding interface.

All EntityManager interfaces extend the generic org.activiti.engine.impl.persistence.entity.EntityManager interface. All implementation classes extend a generic _AbstractEntityManager_ interface.

Also, for consistency:
* The UserIdentityManager interface has been renamed to UserEntityManager
* The GroupIdentityManager interface has been renamed to GroupEntityManager


=== PersistentObject renamed to Entity

The class _org.activiti.engine.impl.db.PersistentObject_ has been renamed to _Entity_ to be consistent with all the other classes (EntityManagers and such)..

All related classes that used the term 'persistent object' have been refactored to 'entity' too.


=== Future breaking changes

The following changes will most likely be applied in a next beta release of Activiti v6:

* The entity cache that is created and used during the execution of a command will be moved up the hierarchy, to be at the same level as the entity managers.
* The persistence operations will be moved to a separate interface out of the EntityManager classes to allow pluggability.


== V5 compatibility

When migrating to Activiti version 6 (which basically means replacing the JAR file on the classpath), all current deployments and process definitions are _tagged_ as being a _version 5_ artifact. At various points (completing a task, starting a new process instance, task assignment, ... quite a long list) the engine will check whether the involved process definition has that _version 5 tag_. If so, it will delegate execution to an _embedded mini version 5 engine_.

This means that the compatibility approach we opted for is that of a phase out: let the current process definitions run in _'version 5 mode_ until the behaviour has been verified and tested to be identical on version 6.

To enable this behavior (by default it is _disabled_!), add the following to the engine config:

----
<property name="activiti5CompatibilityEnabled" value="true" />
----

*and* add the *activiti5-compatibility* jar to your classpath (manually or through a dependency mechanism like Maven)..

In case the default implementation _org.activiti.compatibility.DefaultActiviti5CompatibilityHandler_ is insufficient, as custom implementation can be created. Set the _activiti5CompatibilityHandlerFactory_ property of the engine configuration to the fully qualified classname to make that happen. That Factory class should produce an instance of the handler responsible for bridging from version 6 to 5.

To move a process definition to run on the version 6 engine, simply redeploy it. New process instances will be running in _version 6 mode_, while existing process instances will run in _version 5 mode).

If for some reason, you'd still want to deploy a new version of a process definition to run in _version 5 mode_, the following code can be used:

----
repositoryService.createDeployment()
      .addClasspathResource("xyz")
      .deploymentProperty(DeploymentProperties.DEPLOY_AS_ACTIVITI5_PROCESS_DEFINITION, Boolean.TRUE)
      .deploy();
----

If you are using the Activiti Spring module additional configuration is needed if you want Activiti 5 compatibility:

----
<property name="activiti5CompatibilityEnabled" value="true" />
<property name="activiti5CompatibilityHandlerFactory" ref="activiti5CompabilityFactory" />

....

<bean id="activiti5CompabilityFactory" class="org.activiti.compatibility.spring.SpringActiviti5CompatibilityHandlerFactory" />
----

*and* add the *activiti5-spring* and *activiti5-spring-compatibility* jars to your classpath (manually or through a dependency mechanism like Maven)..
