
== 开始 Getting Started

=== Flowable是什么？ What is Flowable?

Flowable是一个使用Java编写的轻量级业务流程引擎。Flowable流程引擎让你可以部署BPMN 2.0流程定义（用于定义流程的行业XML标准），创建这些流程定义的流程实例，进行查询，访问运行中或历史的流程实例与相关数据，等等很多。这个章节将使用在你自己的开发环境中可以使用的例子，逐步介绍各种概念与API，

Flowable可以十分灵活地加入你的应用/服务/构架。可以将jar形式发布的Flowable库加入应用或服务，来__嵌入__引擎。以jar形式发布使Flowable可以轻易加入任何Java环境：Java SE；Tomcat、Jetty或Spring之类的servlet容器；Jboss或Websphere之类的Java EE服务器，等等。另外，也可以使用Flowable REST API通过HTTP通信。也有Flowable Application，提供了直接可用的UI，可以使用流程与任务。

所有设置Flowable方法的共同点是核心引擎，其可被看做是一组服务的集合，暴露了管理与执行业务流程的API。下面的各种教程都以设置与使用核心引擎的介绍开始。后续章节都建立在之前章节中获取的知识之上。

* <<getting.started.command.line,第一节>>展示了以最简单的方式运行Flowable的方法：只使用Java SE的标准Java main方法。这里也会介绍许多核心概念与API。
* <<getting.started.rest,Flowable REST API章节>>展示了如何通过REST运行及使用相同的API。
* <<getting.started.flowable.app,Flowable APP章节>>将介绍直接可用的Flowable UI的基本方法。

=== Flowable与Activiti (Flowable and Activiti)

Flowable是Activiti(Alfresco的注册商标)的分支。在下面的章节中，你会注意到包名，配置文件等等，都仍使用__activiti__。

[[getting.started.command.line]]
=== 构建一个命令行程序 Building a command-line application

==== 创建一个流程引擎 Creating a process engine

在本教程中，将构建一个简单的例子，以展示如何创建一个Flowable流程引擎，介绍一些核心概念，并展示如何使用API。截图使用Eclipse，但实际上可以使用任何IDE。我们使用Maven获取Flowable依赖及管理构建，但是类似的任何其它方法也都可以使用（Gradle，Ivy，等等）。

我们将构建的例子是一个简单的__请假(holiday request)__流程：

* __雇员(employee)__申请几天的假期
* __经理(manager)__批准或驳回申请
* 模拟将申请注册到某个外部系统，并给雇员发送结果邮件

首先，通过__File -> New -> Other -> Maven Project__创建一个新的Maven项目

image::images/getting.started.new.maven.png[align="center"]

在下一界面中，选中'__create a simple project (skip archetype selection)__'

image::images/getting.started.new.maven2.png[align="center"]

填入__'Group Id'__与__'Artifact id'__:

image::images/getting.started.new.maven3.png[align="center"]

这样就建立了空的Maven项目，然后添加两个依赖：

* Flowable流程引擎，使我们可以创建一个ProcessEngine流程引擎对象，并访问Flowable API。
* 一个内存数据库，本例中为H2，因为Flowable引擎在运行流程实例时，需要使用数据库来存储执行与历史数据。请注意H2依赖包含了数据库__及__驱动。如果使用其他数据库（例如PostgreSQL，MySQL等），需要添加对应的数据库驱动依赖。

在你的__pom.xml__文件中添加下列行：

[source,xml,linenums]
----
<dependencies>
  <dependency>
    <groupId>org.flowable</groupId>
    <artifactId>flowable-engine</artifactId>
    <version>6.0.0.RC1-SNAPSHOT</version>
  </dependency>
  <dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>1.4.192</version>
  </dependency>
</dependencies>
----

如果由于某些原因，依赖jar无法自动获取，可以右键点击项目，并选择'__Maven -> Update Project__'以强制手动刷新（一般不会需要这么操作）。在这个项目中的'__Maven Dependencies__'下，可以看到__flowable-engine__与许多其他依赖。

创建一个新的Java类，并添加标准的Java main方法：

[source,java,linenums]
----
package org.flowable;

public class HolidayRequest {

  public static void main(String[] args) {

  }

}
----

首先要做的是初始化一个**ProcessEngine**流程引擎实例。这是一个线程安全的对象，因此通常只需要在一个应用中初始化一次。__ProcessEngine__由一个**ProcessEngineConfiguration**实例创建。该实例可以配置与调整流程引擎的设置。通常，使用一个配置XML文件创建__ProcessEngineConfiguration__，但是（像在这里做的一样）也可以编程方式创建它。__ProcessEngineConfiguration__最少需要配置一个数据库的JDBC连接：

[source,java,linenums]
----
package org.flowable;

import org.activiti.engine.ProcessEngine;
import org.activiti.engine.ProcessEngineConfiguration;
import org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration;

public class HolidayRequest {

  public static void main(String[] args) {
    ProcessEngineConfiguration cfg = new StandaloneProcessEngineConfiguration()
      .setJdbcUrl("jdbc:h2:mem:flowable;DB_CLOSE_DELAY=-1")
      .setJdbcUsername("sa")
      .setJdbcPassword("")
      .setJdbcDriver("org.h2.Driver")
      .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);

    ProcessEngine processEngine = cfg.buildProcessEngine();
  }

}
----

在上面的代码中，第10行创建了一个__独立(standalone)__配置对象。这里的__'独立'__指的是引擎是完全独立创建及使用的（而不是在例如Spring环境中使用，这时需要使用__SpringProcessEngineConfiguration__类代替）。第11至14行中，传递了一个内存H2数据库实例的JDBC连接参数。请注意这样的数据库在JVM重启后会消失。如果需要永久保存数据，需要切换为持久化数据库，并相应切换连接参数。第15行中，设置了一个__true__标志，确保在JDBC参数连接的数据库中，数据库表结构不存在时，会创建相应的表结构。另外，Flowable也提供了一组SQL文件，可用于手动创建所有表的数据库表结构。

然后使用这个配置创建**ProcessEngine**对象（第17行）。

这样就可以运行了。在Eclipse中最简单的方法是右键点击类文件，选择__Run As -> Java Application__

image::images/getting.started.run.main.png[align="center"]

应用运行没有问题，但也没有在控制台提供有用的信息，只有一条消息提示日志没有正确配置：

image::images/getting.started.console.logging.png[align="center"]

Flowable使用link:$$http://www.slf4j.org/$$[SLF4J]作为内部日志框架。在这个例子中，我们在SLF4J之上使用log4j。在pom.xml文件中添加下列依赖：

[source,xml,linenums]
----
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-api</artifactId>
  <version>1.7.21</version>
</dependency>
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-log4j12</artifactId>
  <version>1.7.21</version>
</dependency>
----

Log4j需要一个配置文件。在__src/main/resources__文件夹下添加__log4j.properties__文件，并写入下列内容：

----
log4j.rootLogger=DEBUG, CA

log4j.appender.CA=org.apache.log4j.ConsoleAppender
log4j.appender.CA.layout=org.apache.log4j.PatternLayout
log4j.appender.CA.layout.ConversionPattern= %d{hh:mm:ss,SSS} [%t] %-5p %c %x - %m%n
----

回到应用。应该可以看到关于引擎启动与创建数据库表结构的提示日志：

image::images/getting.started.console.logging2.png[align="center"]

这样就得到了一个启动可用的流程引擎。接下来为它提供一个流程！

==== 部署一个流程定义 Deploying a process definition

我们要构建的流程是一个非常简单的请假流程。Flowable引擎需要流程定义为BPMN 2.0格式，这是一个业界广泛接受的XML标准。在Flowable术语中，我们将其称为一个**流程定义(process definition)**。一个__流程定义__可以启动多个**流程实例(process instance)**。__流程定义__可以看做是重复执行流程的蓝图。在这个例子中，__流程定义__定义了请假的各个步骤，而一个__流程实例__对应某个雇员提出的一个请假申请。

BPMN 2.0存储为XML，包含可视化的部分：使用标准方式定义了每个步骤类型（人工任务，自动服务调用，等等）如何呈现，以及如何互相连接。这样BPMN 2.0标准使技术人员与业务人员能用双方都能理解的方式交流业务流程。

我们要使用的流程定义为：

image::images/getting.started.bpmn.process.png[align="center"]

这个流程应该已经十分自我解释了，但为了明确起见，描述一下不同的部分：

* 我们假定启动流程需要提供一些信息，例如雇员名字、请假时长以及描述。当然，这些可以单独建模为流程中的第一步。但是如果将它们作为流程的“输入信息”，就能保证只有在实际请求时才会建立一个流程实例。否则（将提交作为流程的第一步），用户可能在提交之前改变主意并取消，但流程实例已经创建了。在某些场景中，就可能影响重要的指标（例如启动了多少申请，但还未完成），取决于业务目标。
* 左侧的圆圈叫做**启动事件(start event)**。这是一个流程实例的起点。
* 第一个矩形是一个**用户任务(user task)**。这是流程中人类用户操作的步骤。在这个例子中，经理需要批准或驳回申请。
* 取决于经理的决定，**排他网关(exclusive gateway)** (带叉的菱形)会将流程实例路由至批准或驳回路径。
* 如果批准，则需要将申请注册至某个外部系统，并跟着另一个用户任务，将经理的决定通知给申请人。当然也可以替换为邮件。
* 如果驳回，则为雇员发送一封邮件。

一般来说，这样的__流程定义__使用可视化建模工具建立，如Flowable Designer(Eclipse)或Flowable Web Modeler。

然而，在这里，我们自己手写XML，以了解BPMN 2.0及其概念。

与上面展示的流程图对应的BPMN 2.0 XML在下面显示。请注意这只包含了“流程部分”。如果使用图形化建模工具，实际的XML文件还将包含“可视化部分”，用于描述图形信息，如下面的流程定义中各个元素的坐标（所有的图形化信息包含在XML的__BPMNDiagram__标签中，作为__definitions__标签的子元素）。

将下面的XML保存在__src/main/resources__文件夹下名为__holiday-request.bpmn20.xml__的文件中。

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
  xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC"
  xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI"
  xmlns:activiti="http://activiti.org/bpmn"
  typeLanguage="http://www.w3.org/2001/XMLSchema"
  expressionLanguage="http://www.w3.org/1999/XPath"
  targetNamespace="http://www.flowable.org/processdef">

  <process id="holidayRequest" name="Holiday Request" isExecutable="true">

    <startEvent id="startEvent"/>
    <sequenceFlow sourceRef="startEvent" targetRef="approveTask"/>

    <userTask id="approveTask" name="Approve or reject request"/>
    <sequenceFlow sourceRef="approveTask" targetRef="decision"/>

    <exclusiveGateway id="decision"/>
    <sequenceFlow sourceRef="decision" targetRef="externalSystemCall">
      <conditionExpression xsi:type="tFormalExpression">
        <![CDATA[
          ${approved}
        ]]>
      </conditionExpression>
    </sequenceFlow>
    <sequenceFlow  sourceRef="decision" targetRef="sendRejectionMail">
      <conditionExpression xsi:type="tFormalExpression">
        <![CDATA[
          ${!approved}
        ]]>
      </conditionExpression>
    </sequenceFlow>

    <serviceTask id="externalSystemCall" name="Enter holidays in external system"   activiti:class="org.flowable.CallExternalSystemDelegate"/>
    <sequenceFlow sourceRef="externalSystemCall" targetRef="holidayApprovedTask"/>

    <userTask id="holidayApprovedTask" name="Holiday approved"/>
    <sequenceFlow sourceRef="holidayApprovedTask" targetRef="approveEnd"/>

    <serviceTask id="sendRejectionMail" name="Send out rejection email" activiti:class="org.flowable.SendRejectionMail"/>
    <sequenceFlow sourceRef="sendRejectionMail" targetRef="rejectEnd"/>

    <endEvent id="approveEnd"/>

    <endEvent id="rejectEnd"/>

  </process>

</definitions>
----

第2至11行看起来挺吓人，但是所有的流程定义中都是一样的。这是一种__样板文件__，需要与BPMN 2.0标准规范完全一致。

每一个步骤，或者在BPMN 2.0术语中称作**'活动(activity)'**，都有一个__id__属性，为其提供一个在XML文件中唯一的标识符。所有的__活动__都可选有一个名字，可以提高流程图的可读性。

__活动__之间使用**顺序流(sequence flow)**连接，在流程图中是一个有向箭头。在执行流程实例时，执行(execution)会从__启动事件__沿着__顺序流__流向下一个__活动__。

The _sequence flows_ leaving the _exclusive gateway_ (the diamond shape with the X) are clearly special: both have a _condition_ defined in the form of an _expression_ (see line 25 and 32). When the process instance execution reaches this _gateway_, the _conditions_ are evaluated and the first that resolves to _true_ is taken. This is what the _exclusive_ stands for here (only one is selected), other types of gateways are of course possible if different routing behavior is needed.

The condition written here as an _expression_ is of the form _${approved}_, which is a shorthand for _${approved == true}_. The variable 'approved' is called a *process variable*. A _process variable_ is a persistent bit of data that is stored together with the process instance and can be used during the lifetime of the process instance. In this case, it does mean that we will have to set this _process variable_ at a certain point (when the manager user task is submitted or, in Flowable terminology, _completed_) in the process instance, as it's not data that is available when the process instance starts.

Now we have the process BPMN 2.0 XML file, we next need to *'deploy'* it to the engine. _Deploying_ a process definition means that:

* the process engine will store the XML file in the database, so it can be retrieved when needed later
* the process definition is parsed to an executable object model internally, so that _process instances_ can be started from it.

To _deploy_ a process definition to the Flowable engine, the _RepositoryService_ is used, which can be retrieved from the _ProcessEngine_ objects. Using the _RepositoryService_, a new _Deployment_ is created by passing the location of the XML file and calling the _deploy()_ method to actually execute it:

[source,java,linenums]
----
RepositoryService repositoryService = processEngine.getRepositoryService();
Deployment deployment = repositoryService.createDeployment()
  .addClasspathResource("holiday-request.bpmn20.xml")
  .deploy();
----

We can now verify that the process definition is known to the engine (and learn a bit about the API) by querying it via the API. This is done by creating a new _ProcessDefinitionQuery_ object via the _RepositoryService_.

[source,java,linenums]
----
ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()
  .deploymentId(deployment.getId())
  .singleResult();
System.out.println("Found process definition : " + processDefinition.getName());
----

==== Starting a process instance

We now have the process definition _deployed_ to the process engine, so _process instances_ can be started using this _process definition_ as 'blueprint'.

To start the process instance, we need to provide some initial _process variables_. Typically, you'll get these via a form that is presented to the user or via a REST API when a process is triggered by something automatic. In this example, we'll keep it simple and use the java.util.Scanner class to simply input some data on the command line:

[source,java,linenums]
----
Scanner scanner= new Scanner(System.in);

System.out.println("Who are you?");
String employee = scanner.nextLine();

System.out.println("How many holidays do you want to request?");
Integer nrOfHolidays = Integer.valueOf(scanner.nextLine());

System.out.println("Why do you need them?");
String description = scanner.nextLine();
----

Next, we can start a _process instance_ via the _RuntimeService_. The collected data is passed as a _java.util.Map_ instance, where the key is the identifier that will be used to retrieve the variables later on. The process instance is started using a _key_. This _key_ matches the _id_ attribute that is set in the BPMN 2.0 XML file, in this case _holidayRequest_.

(note: there are many ways you'll learn later on to start a process instance, beyond using a key)

[source,xml]
----
<process id="holidayRequest" name="Holiday Request" isExecutable="true">
----

[source,java,linenums]
----
RuntimeService runtimeService = processEngine.getRuntimeService();

Map<String, Object> variables = new HashMap<String, Object>();
variables.put("employee", employee);
variables.put("nrOfHolidays", nrOfHolidays);
variables.put("description", description);
ProcessInstance processInstance =
  runtimeService.startProcessInstanceByKey("holidayRequest", variables);
----

When the process instance is started, an *execution* is created and put in the start event. From there, this _execution_ follows the sequence flow to the user task for the manager approval and executes the user task behavior. This behavior will create a task in the database that can be found using queries later on. A user task is a _wait state_ and the engine will stop executing anything further, thus returning the API call.

==== Sidetrack: transactionality

In Flowable, database transactions play a crucial role, to guarantee data consistency and solve concurrency problems. When you make a Flowable API call, by default, everything is synchronous and part of the same transaction. Meaning: when the method call returns, a transaction will be started and committed.

When a process instance is started, there will be *one database transaction* from the start of the process instance to the next _wait state_. In this example, this is the first user task. When the engine reaches this user task, the state is persisted to the database and the transaction is committed and the API call returns.

In Flowable, when continuing a process instance, there will always be one database transaction going from the previous _wait state_ to the next _wait state_. Once persisted, the data can be in the database for a long time, even years if it has to be, until an API call is executed that takes the process instance further. Note that no computing nor memory resources are consumed when the process instance is in such a wait state, waiting for the next API call.

In the example here, when the first user task is completed, one database transaction will be used to go from the user task through the exclusive gateway (the automatic logic) until the second user task. Or straight to the end with the other path.


==== Querying and completing tasks

In a more realistic application, there will be a user interface where the employees and the managers can log in and see their task lists. In such task list, they can inspect the process instance data which is stored as _process variables_ and decide what they want to do with the task. In this example, we will mimic these task lists by executing the API calls that normally would behind a service call that drives a UI.

We haven't yet configured the assignment for the user tasks. We want the first task to go the the 'managers' group and the second user task to be assigned to the original requester of the holiday. To do this, add the _candidateGroups_ attribute to the first task:

[source,xml]
----
<userTask id="approveTask" name="Approve or reject request" activiti:candidateGroups="managers"/>
----

and the _assignee_ attribute to the second task as shown below. Note that we're not using a static value like the 'managers' value above, but a dynamic assignment based on a process variable that we've passed when the process instance was started:

[source,xml]
----
<userTask id="holidayApprovedTask" name="Holiday approved" activiti:assignee="${employee}"/>
----

To get the actual task list, we create a _TaskQuery_ via the _TaskService_ and we configure the query to only return the tasks for the 'managers' group:

[source,java,linenums]
----
TaskService taskService = processEngine.getTaskService();
List<Task> tasks = taskService.createTaskQuery().taskCandidateGroup("managers").list();
System.out.println("You have " + tasks.size() + " tasks:");
for (int i=0; i<tasks.size(); i++) {
  System.out.println((i+1) + ") " + tasks.get(i).getName());
}
----

Using the task identifier, we can now get the specific process instance variables and show on the screen the actual request:

[source,java,linenums]
----
System.out.println("Which task would you like to complete?");
int taskIndex = Integer.valueOf(scanner.nextLine());
Task task = tasks.get(taskIndex - 1);
Map<String, Object> processVariables = taskService.getVariables(task.getId());
System.out.println(processVariables.get("employee") + " wants " + processVariables.get("nrOfHolidays") + " of holidays. Do you approve this?");
----

Which, if you run this, should look something like this:

image::images/getting.started.console.logging3.png[align="center"]

The manager can now *complete the task*. In reality, this often means that a form is sumitted by the user. The data from the form is then passed as _process variables_. Here, we'll mimic this by passing a map with the 'approved' variable (the name is important, as it's used later on in the conditions of the sequence flow!) when the task is completed:

[source,java,linenums]
----
boolean approved = scanner.nextLine().toLowerCase().equals("y");
variables = new HashMap<String, Object>();
variables.put("approved", approved);
taskService.complete(task.getId(), variables);
----

The task is now completed and one of the two paths leaving the exclusive gateway is selected based on the 'approved' process variable.

[[getting.started.delegate]]
==== Writing a JavaDelegate

There is a last piece of the puzzle still missing: we haven't implemented the automatic logic that will get executed when the request is approved. In the BPMN 2.0 xml this is a *service task* and it looked above like:

[source,xml]
----
<serviceTask id="externalSystemCall" name="Enter holidays in external system"   activiti:class="org.flowable.CallExternalSystemDelegate"/>
----

In reality, this logic could be anything ranging from doing an HTTP REST call to some system, to doing some legacy code calls to a system the company has been using for decades. We won't implement the actual logic here, but have a simple logging statement inside.

Create a new class (_File -> New -> Class_ in Eclipse), fill in _org.flowable_ as package name and _CallExternalSystemDelegate_ as class name. Make that class implement the _org.activiti.engine.delegate.JavaDelegate_ interface and implement the _execute_ method:

[source,java,linenums]
----
package org.flowable;

import org.activiti.engine.delegate.DelegateExecution;
import org.activiti.engine.delegate.JavaDelegate;

public class CallExternalSystemDelegate implements JavaDelegate {

	public void execute(DelegateExecution execution) {
		System.out.println("Calling the external system for employee "
      + execution.getVariable("employee"));
	}

}
----

When the _execution_ arrives at the _service task_, the class that is referenced in the BPMN 2.0 xml is instantiated and called.

When running the example now, the logging message is shown, demonstrating the custom logic is indeed executed:

image::images/getting.started.console.logging4.png[align="center"]


==== Working with historical data

One of the many reasons for choosing to use a process engine like Flowable is because it automatically stores *audit data* or *historical data* for all the process instances. This data allows the creation of rich reports that give insights into how the company works, where the bottlenecks are, etc.

For example, suppose we want to show the duration of the process instance that we've been executing so far. To do this, we get the _HistoryService_  from the _ProcessEngine_ and create a query for _historical activities_. In the snippet below you can see we add some additional filtering:

* only the activities for one particular process instance
* only the activities which are finished

The results are also sorted by end time, meaning that we'll get them in execution order.

[source,java,linenums]
----
HistoryService historyService = processEngine.getHistoryService();
List<HistoricActivityInstance> activities =
  historyService.createHistoricActivityInstanceQuery()
   .processInstanceId(processInstance.getId())
   .finished()
   .orderByHistoricActivityInstanceEndTime().asc()
   .list();

for (HistoricActivityInstance activity : activities) {
  System.out.println(activity.getActivityId() + " took "
    + activity.getDurationInMillis() + " milliseconds");
}
----

Running the example again, we now see something like this in the console:

----
startEvent took 1 milliseconds
approveTask took 2638 milliseconds
decision took 3 milliseconds
externalSystemCall took 1 milliseconds
----

==== Conclusion

This tutorial introduced various Flowable and BPMN 2.0 concepts and terminology while also demonstrating how use the Flowable API programmatically.

Of course, this is just the start of the journey. The following sections will dive more deeply into the many options and features that the Flowable engine supports. Other sections go into the various ways the Flowable engine can be set up and used, and describe in detail all the BPMN 2.0 constructs that are possible.

[[getting.started.rest]]
=== Getting started with the Flowable REST API

This section shows the same example as the <<getting.started.command.line, previous section>>: deploying a process definition, starting a process instance, getting a task list and completing a task. If you haven't read that section, it might be good to skim through it to get an idea of what is done there.

This time, the Flowable REST API is used instead of the Java API. You'll soon notice that the REST API closely matches the Java API, and knowing the one automatically means that you can find your way around the other.

To get a full detailed overview of the Flowable REST API, check out the <<restApiChapter, REST API chapter>>.

==== Setting up the REST application

When you download the .zip file from the flowable.org website, the REST application can be found in the _wars_ folder. You'll need a servlet container like link:$$http://tomcat.apache.org//$$[Tomcat], link:$$http://www.eclipse.org/jetty//$$[Jetty], etc. to run the war file.

When using Tomcat the steps are as follows:

* Download and unzip the latest and greatest Tomcat zip file (choose the 'Core' distribution from the Tomcat website).
* Copy the flowable-rest.war file from the _wars_ folder of the unzipped Flowable distribution to the _webapps_ folder of the unzipped Tomcat folder.
* On the command line, go to the _bin_ folder of the Tomcat folder.
* Execute '_./catalina run_' to boot up the Tomcat server.

During the server boot up, you'll notice some Flowable logging messages passing by. At the end a message like '_INFO [main] org.apache.catalina.startup.Catalina.start Server startup in xyz ms_' signifies that the server is ready to receives requests. Note that by default an in-memory H2 database instance is used, which means that data won't survive a server restart.

In the following sections, we'll use cURL to demonstrate the various REST calls. All REST calls are by default protected with _basic authentication_. The user 'kermit' with password 'kermit' is used in all calls.

After bootup, verify the application is running correctly by executing

----
curl --user kermit:kermit http://localhost:8080/flowable-rest/service/management/engine
----

If you get back a proper json response, the REST API is up and running.

==== Deploying a process definition

The first step is to deploy a process definition. With the REST API, this is done by uploading a .bpmn20.xml file (or .zip file for multiple process definitions) as 'multipart/formdata':

----
curl --user kermit:kermit -F "file=@holiday-request.bpmn20.xml" http://localhost:8080/flowable-rest/service/repository/deployments
----

To verify that the process definition is deployed correctly, the list of process definitions can be requested:

----
curl --user kermit:kermit http://localhost:8080/flowable-rest/service/repository/process-definitions
----

which returns a list of all process definitions currently deployed to the engine.


==== Start a process instance

Starting a process instance via the REST API is similar to doing the same via the Java API: a _key_ is provided to identify the process definition to use along with a map of initial process variables:

----
curl --user kermit:kermit -H "Content-Type: application/json" -X POST -d '{ "processDefinitionKey":"holidayRequest", "variables": [ { "name":"employee", "value": "John Doe" }, { "name":"nrOfHolidays", "value": 7 }]}' http://localhost:8080/flowable-rest/service/runtime/process-instances
----

which returns something like

----
{"id":"43","url":"http://localhost:8080/flowable-rest/service/runtime/process-instances/43","businessKey":null,"suspended":false,"ended":false,"processDefinitionId":"holidayRequest:1:42","processDefinitionUrl":"http://localhost:8080/flowable-rest/service/repository/process-definitions/holidayRequest:1:42","activityId":null,"variables":[],"tenantId":"","completed":false}
----

==== Task list and completing a task

When the process instance is started, the first task is assigned to the 'managers' group. To get all tasks for this group, a task query can be done via the REST API:

----
curl --user kermit:kermit -H "Content-Type: application/json" -X POST -d '{ "candidateGroup" : "managers" }' http://localhost:8080/flowable-rest/service/query/tasks
----

which returns a list of all tasks for the 'managers' group

Such a task can now be completed using:

----
curl --user kermit:kermit -H "Content-Type: application/json" -X POST -d '{ "action" : "complete", "variables" : [ { "name" : "approved", "value" : true} ]  }' http://localhost:8080/flowable-rest/service/runtime/tasks/25
----

However, you most likely will get an error like:

----
{"message":"Internal server error","exception":"couldn't instantiate class org.flowable.CallExternalSystemDelegate"}
----

This means that the engine couldn't find the _CallExternalSystemDelegate_ class that is referenced in the service task. To solve this, the class needs to be put on the classpath of the application (which will require a restart). Create the class as described in <<getting.started.delegate, this section>>, package it up as a jar and put it in the _WEB-INF/lib_ folder of the flowable-rest folder under the _webapps_ folder of Tomcat.
